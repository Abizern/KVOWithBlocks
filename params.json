{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Kvowithblocks","google":"UA-5015208-5","tagline":"KVO with a block instead of a callback","body":"# KVOWithBlocks\r\n\r\nA category on NSObject that allows you observe a keypath passing in a block to\r\nexecute when the keypath changes instead of using a callback method.\r\n\r\nThis works on iOS and OS X.\r\n\r\nWhy? Blocks are funky. They let you define an action at the same time as you are\r\nsetting up a observation. In most cases this leads to clearer code than using a\r\ncallback.\r\n\r\n## Dependencies\r\n\r\n+ ARC. This is written to be dropped into a ARC project, there are no macros to\r\ngracefully handle using it in MRC or GC apps\r\n+ Since it needs ARC, it needs OS X 10.7 and iOS 4.\r\n+ My [CommonMacros.h](https://gist.github.com/325926) file which is available on\r\nGithub. This is used for assertions and logging. Since I have it in all my\r\nprojects it's not an issue with me. If you feel it's too much bother just for\r\nthis small category, then feel free to replace `DLog`, `ALog` and `ZAssert` with\r\nwhatever your preferred replacements are.\r\n\r\n## Usage\r\n\r\nQuite simple, there are only three methods provided by the category\r\n\r\n### jcsAddObserverForKeyPath:options:queue:block:\r\n\r\nThis is the main method for registering for an observer. It takes a keyPath and\r\noptions as is usual for registering KVO observations, but additionally it takes\r\nan NSOperationQueue and a block. The block is run on the queue when a change is\r\nobseverved to the key path. If the queue is nil, then the block is run on the\r\ncalling thread.\r\n\r\nThe block has no return value and is passed in the change dictionary for the\r\nobservation.  It is typedefed as:\r\n\r\n```objc\r\ntypedef void (^jcsObservationBlock)(NSDictionary *change);\r\n```\r\n\r\nWhen registering for observation, an opaque object reference is returned, which\r\nis used to unregister for the observation.\r\n\r\n**Example**\r\n\r\n```objc\r\n// Assume you have an iVar: id _observer to hold the opaque reference\r\nNSOperationQueue *queue = [NSOperationQueue new];\r\n_observer =\r\n[self jcsAddObserverForKeyPath:@\"self.stringProperty\" options:NSKeyValueObservingOptionNew queue:queue block:^(NSDictionary *change) {\r\n    NSLog(@\"New string value %@\", [change objectForKey:NSKeyValueChangeNewKey]);\r\n}];\r\n```\r\n\r\n### jcsAddObserverForKeyPath:withBlock:\r\n\r\nThis is a convenience method that runs the provided block on the calling\r\nqueue. The options are `NSKeyValueObservingOptionNew` so that the change\r\ndictionary has a key of `NSKeyValueChangeNewKey`.\r\n\r\nWhen registering for this observation, an opaque object reference in returned,\r\nwhich is used to unregister for the observation.\r\n\r\n**Example**\r\n\r\n```objc\r\n// Assume you have an iVar: id _observer to hold the opaque reference\r\n_observer =\r\n[self jcsAddObserverForKeyPath:@\"self.stringProperty\" withBlock:^(NSDictionary *change) {\r\n    NSLog(@\"New string value %@\", [change objectForKey:NSKeyValueChangeNewKey]);\r\n}];\r\n```\r\n### jcsRemoveObserver:\r\n\r\nThis is used to remove the observation object using the opaque reference\r\nreturned when registering. At the very least this should be done in the\r\n`dealloc` method. It is safe to attempt to unregister an observer that has\r\nalready been unregistered.\r\n\r\n**Example**\r\n\r\n```objc\r\n// Assuming an iVar: id _observer\r\n- (void)dealloc {\r\n    [self jcsRemoveObserver:_observer];\r\n}\r\n```\r\n\r\n## Examples\r\n\r\nThe development branch (the branch structure is described below) contains an\r\nXcode Workspace with two example projects that show simple observations for\r\nblocking and non-blocking observers.\r\n\r\n## Branch structure for submodules\r\n\r\nThere are two branches to this repository, *master* and *development*, these\r\nmake it easier to use the same repository for developing as well as for sharing\r\nthe code as a Git submodule.\r\n\r\n### The master branch\r\n\r\nThe master branch just contains the class category and this README file. It is\r\nthe one to use if you want to add it as a submodule to your project. This should\r\nbe treated as a readonly branch. *do not perform any development on this\r\nbranch*.\r\n\r\nif you are using this as a submodule, keep up to date with the latest changes by\r\n\r\n### The development branch\r\n\r\nThe development branch contains the category files as well as Xcode projects for\r\ndevelopment and demonstration. This is the branch where development should be\r\nperformed, the changes push back to the master branch cleanly through the magic\r\nof careful merging.\r\n\r\nTo add the development branch rather than master, simply use the -b flag when\r\ncloning, as shown below.\r\n\r\n    git submodule add -b development\r\n    https://github.com/Abizern/KVOWithBlocks.git\r\n\r\nThere are Unit Tests for the category in each of the OS X and iOS projects, but\r\nthese are shared between the two projects.\r\n\r\n### Artefacts\r\n\r\nSometimes, there may be artefacts left over when switching from master to\r\ndevelopment. These are files that are ignored by Git and are easily cleaned up\r\nby running\r\n\r\n    git clean -dxf\r\n\r\n## License (MIT)\r\n\r\nStandard MIT licence.\r\n\r\nI don't need attribution, it's only a small bit of code. Be inspired to write\r\nyour own block based replacements.\r\n\r\n## Acknowledgments\r\n\r\nBased on:\r\n+ [KVO+Blocks](https://gist.github.com/153676) by Andy Matuschak\r\n+ [DGKVOBlocks](https://github.com/dannygreg/DGKVOBlocks) by Danny Greg\r\n\r\nI make no apologies for taking the bits I like from them.\r\n"}